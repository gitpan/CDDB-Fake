#!/usr/bin/perl -w
my $RCS_Id = '$Id: ls2nocddb.pl,v 1.5 2003/07/26 15:52:16 jv Exp $ ';

# Author          : Johan Vromans
# Created On      : Tue Sep 15 15:59:04 1992
# Last Modified By: Johan Vromans
# Last Modified On: Sat Jul 26 17:40:02 2003
# Update Count    : 92
# Status          : Unknown, Use with caution!

################ Common stuff ################

use strict;

# Package or program libraries, if appropriate.
# $LIBDIR = $ENV{'LIBDIR'} || '/usr/local/lib/sample';
# use lib qw($LIBDIR);
# require 'common.pl';

# Package name.
my $my_package = 'Sciurix';
# Program name and version.
my ($my_name, $my_version) = $RCS_Id =~ /: (.+).pl,v ([\d.]+)/;
# Tack '*' if it is not checked in into RCS.
$my_version .= '*' if length('$Locker:  $ ') > 12;

use FindBin;
use lib $FindBin::Bin;

################ Command line parameters ################

use Getopt::Long 2.13;

# Command line options.
my $length = 0;			# calculate length of tracks
my $verbose = 0;		# verbose processing

# Development options (not shown with -help).
my $debug = 0;			# debugging
my $trace = 0;			# trace (show process)
my $test = 0;			# test mode.

# Process command line options.
app_options();

# Post-processing.
$trace |= ($debug || $test);

################ Presets ################

my $TMPDIR = $ENV{TMPDIR} || $ENV{TEMP} || '/usr/tmp';

################ The Process ################

foreach my $dir ( @ARGV ) {

    unless ( -d $dir ) {
	warn("$dir: not a directory -- skipped\n");
	next;
    }
    if ( -s "$dir/.nocddb" ) {
	warn("$dir/.nocddb: exists -- directory skipped\n");
	next;
    }

    $dir =~ s;/+$;;;
    my @a = split('/', $dir);
    my ($artist, $album) = ("","");
    if ( @a >= 2 ) {
	$artist = neat($a[-2]);
	$album = neat($a[-1]);
    }

    my @files = sort map { $1 if /([^\/]+)\.mp3$/ } glob("$dir/[0-9]*.mp3");

    open(my $fh, ">$dir/.nocddb") or die("$dir/.nocddb: $!\n");
    print $fh ("$artist / $album\n\n");

    my $prev = 0;
    foreach my $file ( @files ) {
	my $mmss;
	$mmss = getlength("$dir/$file.mp3") if $length;
	$file =~ s/^(\d+)_(-_)?//;
	$prev++;
	while ( $prev < $1 ) {
	    printf $fh ("  %2d. %s\n", $prev, "Unknown");
	    $prev++;
	}
	printf $fh ("  %2d. %s%s\n", $1, neat($file),
		    $length ? "\t\t$mmss" : "");
    }

    print $fh ("\nGenerated by $my_name $my_version on ".
	       localtime(time)."\n");
    close($fh);

}

exit 0;

################ Subroutines ################

sub neat {
    local($_) = shift;
    s/__/:_/g;
    s/_s_/'s_/gi;
    s/_m_/'m_/gi;
    s/(you|we|they)_re_/$1're_/gi;
    s/_/ /g;
    s/\s+/ /g;
    s/(^|-|\s|\(|\[)(.)/$1.ucfirst($2)/eg;
    $_;
}

sub getlength {
    my ($file) = @_;

    unless ( eval { require MPEG::Audio::Frame; } ) {
	warn("Cannot load MPEG::Audio::Frame\n");
	$length = 0;
	return;
    }

    return " -:--" unless -f $file;

    my $f;
    unless ( open($f, '<', $file) ) {
	warn("$file: $!\n");
	return " -:--";
    }

    my $length;
    my $frames = 0;
    while ( my $frame = MPEG::Audio::Frame->read($f)) {
	$length += $frame->seconds;
    }
    return dptime_formatted($length);
}

sub dptime_formatted {
    my ($t) = (@_);
    $t += 0.5;
    $t = int($t);
    my $s = $t % 60;
    my $m = int($t / 60);
    sprintf("%2d:%02d", $m, $s);
}

################ Subroutines ################

sub app_options {
    my $help = 0;		# handled locally
    my $ident = 0;		# handled locally

    # Process options, if any.
    # Make sure defaults are set before returning!
    return unless @ARGV > 0;

    if ( !GetOptions(
		     'length'	=> \$length,
		     'ident'	=> \$ident,
		     'verbose'	=> \$verbose,
		     'trace'	=> \$trace,
		     'help|?'	=> \$help,
		     'debug'	=> \$debug,
		    ) or $help )
    {
	app_usage(2);
    }
    app_ident() if $ident;
}

sub app_ident {
    print STDERR ("This is $my_package [$my_name $my_version]\n");
}

sub app_usage {
    my ($exit) = @_;
    app_ident();
    print STDERR <<EndOfUsage;
Usage: $0 [options] [file ...]
    -help		this message
    -ident		show identification
    -verbose		verbose information
EndOfUsage
    exit $exit if defined $exit && $exit != 0;
}

=head1 NAME

ls2nocddb - produce CDDB::Fake info from a directory

=head1 SYNOPSIS

    ls2nocddb [ options ] directory ...

Options:

    --length    include length information
    --verbose   more verbose information
    --help      help message

=head1 DESCRIPTION

This program can generate CDDB::Fake information data from a directory
containing MP3 files.

It requires the directory to be named Artist_Name/Album_Title.

The MP3 files in the directory must be named NN_Track_Title.mp3, where
I<NN> is the track number.

When the package MP3::Audio::Frame is available, the program can add
the lengths of the tracks to the generated information.

For example: Given the directory Jazz/Dick_Onstenk/Dick's_Jazz_Stuff
with the following files:

    01_Body_And_Soul.mp3
    02_Fly_Me_To_The_Moon.mp3
    03_Lover_Man.mp3
    04_Freddie_Freeloader.mp3
    05_Billie's_Bounce.mp3
    06_Softly_As_In_A_Morning_Sunrise.mp3

Then running B<ls2nocddb> with option C<--length> and argument
C<Jazz/Dick_Onstenk/Dick's_Jazz_Stuff>, will create a file named
C<.nocddb> in that directory, with the following contents:

    Dick Onstenk / Dick's Jazz Stuff

	 1. Body And Soul			 3:17
	 2. Fly Me To The Moon			 4:20
	 3. Lover Man				 6:16
	 4. Freddie Freeloader			 5:32
         5. Billie's Bounce			 4:22
         6. Softly As In A Morning Sunrise	 3:55

    Generated by ls2nocddb 1.4 on Fri Jul 25 14:31:41 2003

=head1 SEE ALSO

L<CDDB::File>.

=head1 DEPENDENCIES

C<MP3::Audio::Frame> (optional). If installed, the program can add the
lengths of the tracks to the generated information.

=head1 AUTHOR

Johan Vromans <jvromans@squirrel.nl>

=head1 COPYRIGHT

This programs is Copyright 2003, Squirrel Consultancy.

This program is free software; you can redistribute it and/or modify
it under the terms of the Perl Artistic License or the GNU General
Public License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

=cut

